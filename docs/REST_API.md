# REST API design

- We do spec-first REST API development.
- The model and code are generated from the spec by a code generator.
- We implement strict input validation, with developer friendly error messages.
- HTTP Method semantics:
    - `GET`: any _read-only_ operation, that does **not** change state. Eg database query, perform calculation, etc.
    - `POST`: must always _create a new entity_. Input can **not** provide an ID, because this is generated by the
      database
      and returned in the HTTP response payload.
    - `PUT`: must always be _idempotent_, which means that executing the same HTTP PUT request a second time must
      **not** change the state.
    - `DELETE`: must always _remove an entity_, at least logically.
    - `PATCH`: use for operations that are not idempotent and do not create or delete an entity. Eg executing a workflow
      that has a cumulative effect.
- We follow the [RESTful API standards](https://aws.amazon.com/what-is/restful-api/) as much as possible, using the
  standard HTTP CRUD methods (POST, GET, PUT, DELETE), but this is **not** a religious dogma.
- Where it makes the API definition simpler, we allow the (mis-)use of the last resource in the URL as a verb,
  indicating that the given operation will be executed on the previous resource. E.g.:
  `ticketing/order/4872345/confirm`.
- TBD by the project: API versioning?

## REST Model design

- Generally speaking, we follow the RESTful guidelines, and model our HTTP payloads as fully fledged objects/entities
  that can be created (POST), updated (PUT), queried (GET) and deleted (DELETE).
- Our `openapi.yaml` specification is maximally strict about mandatory and read-only attributes.
- Having a single schema definition for all HTTP methods presents a problem, because some attributes will be mandatory
  in a PUT operation, and meaningless in a POST operation, and some volatile or calculated values will only have meaning
  in a GET request. Eg an entity's ID, version and creation date should only be included in a PUT, not in a POST.
- This is why our REST API model for a given entity is split into the following data types, using the Customer entity as
  an example:
    - Customer - full model, including volatile or calculated values, used in GET requests.
    - CreateCustomerCommand - used in POST requests, does not include ID, creation date, or other any data that is
      generated on the server at creation time.
    - CreateCustomerResponse - response from POST request, containing the ID, creation date, etc.
    - UpdateCustomerCommand - used in PUT request, includes the full model, but not including volatile or calculated
      values.
    - The DELETE operation does not require a schema - the entity to be removed is specified by its ID in a URL path
      parameter.
- Splitting our model like this allows us to have strict validation on attributes in our schema.
- Use inheritance (`allof`) in the schema model to prevent duplication, but remember that the attribute definitions will
  be different between the POST/PUT and the GET model, in terms of read-only. It's OK to inherit the `Update` model from
  the `Create` model if we are just adding more attributes.

## OpenApi

- The API is defined in OpenApi YAML notation, which is stored in the xxx-api-spec submodule, in the file openapi.yaml.
  e.g. [openapi.yaml](./customer-service/customer-application/customer-api-spec/src/main/spec/openapi.yaml), or
  [openapi.yaml](./order-service/order-application/order-api-spec/src/main/spec/openapi.yaml)
- This YAML file is used to define the external REST API spec, and
  the [OpenApiTools code generator](https://github.com/OpenAPITools/openapi-generator#readme) is used to generate the
  required Java stubs and skeletons.
- It will also be used to generate a Swagger test API for the REST APIs, which will feed the microservice.
- Code is generated to the build/ directory structure. Only the `openapi.yaml` spec is committed to Git.
