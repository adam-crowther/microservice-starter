# REST API design

- We do spec-first REST API development.
- The model and code are generated from the spec by a code generator.
- We implement strict input validation, with developer friendly error messages.
- HTTP Method semantics:
    - `GET`: any _read-only_ operation, that does **not** change state. Eg database query, perform calculation, etc.
    - `POST`: must always _create a new entity_. Input can **not** provide an ID, because this is generated by the
      database
      and returned in the HTTP response payload.
    - `PUT`: must always be _idempotent_, which means that executing the same HTTP PUT request a second time must
      **not** change the state.
    - `DELETE`: must always _remove an entity_, at least logically.
    - `PATCH`: use for operations that are not idempotent and do not create or delete an entity. Eg executing a workflow
      that has a cumulative effect.
- We follow the [RESTful API standards](https://aws.amazon.com/what-is/restful-api/) as much as possible, using the
  standard HTTP CRUD methods (POST, GET, PUT, DELETE), but this is **not** a religious dogma.
- Where it makes the API definition simpler, we allow the (mis-)use of the last resource in the URL as a verb,
  indicating that the given operation will be executed on the previous resource. E.g.:
  `ticketing/order/4872345/confirm`.
- TBD by the project: API versioning?

## REST Model design

- Generally speaking, we follow the RESTful guidelines, and model our HTTP payloads as fully fledged objects/entities
  that can be created (POST), updated (PUT), queried (GET) and deleted (DELETE).
- Our `openapi.yaml` specification is maximally strict about mandatory and read-only attributes.
- Having a single schema definition for all HTTP methods presents a problem, because some attributes will be mandatory
  in a PUT operation, and meaningless in a POST operation, and some volatile or calculated values will only have meaning
  in a GET request. Eg an entity's ID, version and creation date should only be included in a PUT, not in a POST.
- This is why our REST API model for a given entity is split into the following data types, using the Customer entity as
  an example:
    - Customer - full model, including volatile or calculated values, used in GET requests.
    - CreateCustomerCommand - used in POST requests, does not include ID, creation date, or other any data that is
      generated on the server at creation time.
    - CreateCustomerResponse - response from POST request, containing the ID, creation date, etc.
    - UpdateCustomerCommand - used in PUT request, includes the full model, but not including volatile or calculated
      values.
    - The DELETE operation does not require a schema - the entity to be removed is specified by its ID in a URL path
      parameter.
- Splitting our model like this allows us to have strict validation on attributes in our schema.
- Use inheritance (`allof`) in the schema model to prevent duplication, but remember that the attribute definitions will
  be different between the POST/PUT and the GET model, in terms of read-only. It's OK to inherit the `Update` model from
  the `Create` model if we are just adding more attributes.

## OpenApi

- The API is defined in OpenApi YAML notation, which is stored in the xxx-api-spec submodule, in the file openapi.yaml.
  e.g. [openapi.yaml](../customer-service/customer-application/customer-api-spec/src/main/spec/openapi.yaml), or
  [openapi.yaml](../order-service/order-application/order-api-spec/src/main/spec/openapi.yaml)
- This YAML file is used to define the external REST API spec, and
  the [OpenApiTools code generator](https://github.com/OpenAPITools/openapi-generator#readme) is used to generate the
  required Java stubs and skeletons.
- It will also be used to generate a Swagger test API for the REST APIs, which will feed the microservice.
- Code is generated to the build/ directory structure. Only the `openapi.yaml` spec is committed to Git.

## REST API Implementation

- The REST API Java interfaces are generated by the OpenApi code generators.
- The implementation class is located in submodule `xxxx-rest-controller`, and is annotated with `@RestController`, e.g.
  [AirlinesController.java](../airline-mdm/airline-mdm-presentation/airline-mdm-rest-controller/src/main/java/com/acroteq/ticketing/airline/service/presentation/rest/AirlinesController.java).
- The implementation class should only do 2 things:
  - Mapping between the API model and the Application-Service DTO model
  - Service calls
- This is infrastructure code, which means that we are **strict** that about not wanting business or application logic
  in there.

## Swagger UI

- For each REST API, we auto-generate a SpringBoot application which exposes a Swagger UI documentation and testing
  front-end.
- The Swagger UI is generated and deployed as a stand-alone application, which delegates to the REST API. This is done
  in order to segregate it from the production code and deployment artifact. In production, the Swagger UI application
  will simply not be deployed.
- This is in order to separate it completely from the production code:  in production the Swagger UI container
  is simply not deployed.
- The UI is available at [http://localhost:828x](http://localhost:828x), where the x is the same digit as the
  port in the rest controller:

| Microservice  | REST API              | Swagger UI            |
 |---------------|-----------------------|-----------------------|
| Airline MDM   | http://localhost:8183 | http://localhost:8283 |
| Customer MDM  | http://localhost:8185 | http://localhost:8285 |
| Order Service | http://localhost:8181 | http://localhost:8281 |

- To allow the Swagger UI client to make requests to the REST container, we need to enable **CORS**, using
  the `@CrossOrigin` annotation in the `@RestController` classes in the `xxxx-rest-controller` submodule.  
  The CORS configuration only allows cross-domain requests from `http://localhost:828x`, so it's not a security
  risk.
